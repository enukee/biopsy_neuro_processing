@page "/processing"
@rendermode InteractiveServer
@inject HttpClient Http
@inject IJSRuntime JSRuntime

<PageTitle>Анализ изображений</PageTitle>

<h1 class="welcome-title">Загрузите изображение</h1>
<p class="intro-text">Загрузите изображение, и мы обработаем его для вас!</p>

<div class="file-input-wrapper">
    <label class="file-input-label" for="file-input">Выберите файл</label>
    <InputFile id="file-input" OnChange="HandleFileSelected" hidden=true accept="image/*" />
</div>

<button class="custom-button" @onclick="ProcessImage" style="margin-left:20px;" disabled="@isProcessBtnDisabled">
    Обработать изображение</button>

<button class="custom-button" @onclick="DownloadProcessedImage" style="margin-left:20px;" disabled="@isDownloadBtnDisabled">
    <img src="box-arrow-down.svg" width="20" height="20">
</button>
<script>
    window.downloadFileFromBase64 = (fileName, base64Data) => {
        const linkSource = base64Data;
        const downloadLink = document.createElement("a");
        downloadLink.href = linkSource;
        downloadLink.download = fileName;
        downloadLink.click();
    }
</script>
<br>

@if (imageDataUrl != null)
{
    <img src="@imageDataUrl" width="300" alt="Загруженное изображение" style="padding: 1em;" />
}

@if (processedImageDataUrl != null)
{
    <img src="@processedImageDataUrl" width="300" alt="Обработанное изображение" style="padding: 1em;" />
}

@code {
    private IBrowserFile selectedFile;
    private string imageDataUrl;
    private string processedImageDataUrl;
    private bool isProcessBtnDisabled = true;
    private bool isDownloadBtnDisabled = true;

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        Console.WriteLine("uploading an image");

        selectedFile = e.File;
        try
        {
            using (var memoryStream = new MemoryStream())
            {
                await selectedFile.OpenReadStream(104857600).CopyToAsync(memoryStream);
                var buffer = memoryStream.ToArray();
                imageDataUrl = $"data:{selectedFile.ContentType};base64,{Convert.ToBase64String(buffer)}";
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading file: {ex.Message}");
        }
        isProcessBtnDisabled = false;

        // Обновляем интерфейс, чтобы отобразить загруженное изображение
        StateHasChanged();
        Console.WriteLine("State has changed called.");
    }

    private async Task ProcessImage()
    {
        Console.WriteLine("image processing");

        if (selectedFile != null)
        {
            await UploadFile(selectedFile);
        }
    }

    private async Task UploadFile(IBrowserFile file)
    {
        var content = new MultipartFormDataContent();
        var streamContent = new StreamContent(file.OpenReadStream(104857600));
        content.Add(streamContent, "file", file.Name);

        Console.WriteLine("Отправляем файл на сервер...");

        var response = await Http.PostAsync("http://127.0.0.1:5000/proceed", content);

        if (response.IsSuccessStatusCode)
        {
            var processedImageBytes = await response.Content.ReadAsByteArrayAsync();
            processedImageDataUrl = $"data:image/jpg;base64,{Convert.ToBase64String(processedImageBytes)}";
            Console.WriteLine("Файл успешно загружен и обработан.");
            isDownloadBtnDisabled = false;
            // Обновляем интерфейс, чтобы отобразить обработанное изображение
            StateHasChanged();
        }
        else
        {
            Console.WriteLine($"Ошибка при загрузке файла: {response.StatusCode}");
        }
    }

    private async Task DownloadProcessedImage()
    {
        if (!string.IsNullOrEmpty(processedImageDataUrl))
        {
            await JSRuntime.InvokeVoidAsync("downloadFileFromBase64", "processed_image.jpg", processedImageDataUrl);
        }
    }
}
